#
# cmake/oxidize.cmake
#
# The MIT License
#
# Copyright (c) 2025 TileDB, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
###############################################################################
#
# Provides functions and definitions for packaging Rust crates into a shared
# library or executable.
#
# The design of the build system is motivated by the following:
#
# 1) This constraint upon Rust FFI described at https://cxx.rs/build/other.html
#    > If you need to link multiple Rust subsystems, you will need to
#    > generate a single staticlib perhaps using lots of extern crate
#    > statements to include multiple Rust rlibs.
#    > Multiple Rust staticlib files are likely to conflict.
#
# 2) Our desire to build a large number of small standalone unit test
#    executables.
#
# 3) Those standalone unit test executables would like to share internal
#    Rust crates and dependencies.
#
# To enable a union of these constraints, we separate the crates which declare
# the `#[cxx::bridge]` modules from the crates which export symbols as a
# static library.
#
# For each top-level build target which integrates Rust, we define a
# Rust `staticlib` crate, e.g. `oxidize_tiledb_core_objects`.
# These crates contain no code and merely re-export the symbols of one or
# more Rust `rlib` (Rust library) crates with `#[cxx::bridge]` modules.
# The `rlib` dependencies may be re-used among an arbitrary number of
# the `staticlib` crates, but as noted each top-level target may link only
# one `staticlib`.
#
# The functions defined in this CMake module encode this relationship:
#
# The `cxxbridge` function declares the source files generated by
# the `#[cxx::bridge]` modules of a particular `rlib` crate.
# It does not generate any targets which are intended to be built,
# it just sets some metadata properties which are used by the
# `oxidize` function.
#
# The `oxidize` function declares the set of `rlib` dependencies that
# are used in one of the `staticlib`. It creates targets which sanitize
# the paths of header files generated by the `#[cxx::bridge]` modules
# and declares an object library which links those `.cc` files together
# with the Rust `staticlib`.
#
# This layout is influenced by our use of the Corrosion open-source project
# which imports a Rust `Cargo.toml` file to into CMake. This generates targets
# for `staticlib`s and executables, but not intermediate `rlib`. This requires
# our `oxidize` function to do most of the work. A positive benefit of this
# is that Cargo is in charge of resolving dependencies inside the Rust
# workspace, not the build configuration produced by CMake. And a positive
# consequence of *that* is that we do not need to declare targets for any
# Rust code beyond what is already described.
#
###############################################################################

include_guard()


#
# Fetch Corrosion cmake functions.
# Corrosion provides functions which declare targets to build
# Rust static libraries and executables.
#
include(FetchContent)
set(FETCHCONTENT_UPDATES_DISCONNECTED TRUE)
FetchContent_Declare(
  Corrosion
  GIT_REPOSITORY https://github.com/corrosion-rs/corrosion.git
    GIT_TAG v0.5 # Optionally specify a commit hash, version tag or branch here
)
# Set any global configuration variables such as `Rust_TOOLCHAIN` before this line!
FetchContent_MakeAvailable(Corrosion)


set(Rust_CARGO_TARGET "x86_64-unknown-linux-gnu") # FIXME

if ("${Rust_CARGO_TARGET}" STREQUAL "")
  message(SEND_ERROR "Variable Rust_CARGO_TARGET is not set")
endif ()


set(CORROSION_BUILD_DIR ${CMAKE_BINARY_DIR}/cargo/build/${Rust_CARGO_TARGET})

#
# `tiledb/oxidize/rust.h`
#
# The `cxx` crate which we use can cause circular dependencies of classes.
# One usually solves this in C++ with forward declarations in one of the
# header files.
#
# The following commands generate `rust.h` which contains
# the standalone "Rust API" generated by `cxx`. This can be used
# to forward-declare Box, Slice, etc.
#
# Shell direction is not guaranteed to work with custom build commands,
# so we populate a copy of the file at build configuration time and then
# copy it to the include directory at build time.
#
set(OXIDIZE_RUST_H ${TILEDB_OXIDIZE_INCLUDE_DIR}/tiledb/oxidize/rust.h)
set(OXIDIZE_RUST_H_SRC ${CMAKE_CURRENT_BINARY_DIR}/rust.h)

set(CARGO_INSTALL_ROOT ${CMAKE_BINARY_DIR}/cargo/install)
set(CARGO_INSTALL_BIN ${CARGO_INSTALL_ROOT}/bin)

execute_process(
  COMMAND
    ${CARGO} install cxxbridge-cmd --root ${CARGO_INSTALL_ROOT}
)
execute_process(
  COMMAND
    ${CMAKE_COMMAND} -E make_directory ${TILEDB_OXIDIZE_INCLUDE_DIR}/tiledb/oxidize
)
execute_process(
  COMMAND
    ${CARGO_INSTALL_BIN}/cxxbridge --header
  OUTPUT_FILE
    ${OXIDIZE_RUST_H_SRC}
)

add_custom_command(
  OUTPUT
    ${OXIDIZE_RUST_H}
  COMMAND
    ${CMAKE_COMMAND} -E copy ${OXIDIZE_RUST_H_SRC} ${OXIDIZE_RUST_H}
  WORKING_DIRECTORY
    ${CMAKE_CURRENT_BINARY_DIR}
)

add_custom_target(
  rust_h
  DEPENDS
    ${OXIDIZE_RUST_H}
)



# Declares a Rust `rlib` crate with one or more `#[cxx::bridge]` modules.
#
# Inputs:
#   NAME crate_name
#   SOURCES source1 source2 ...
#
# Outputs:
#   A fake interface library target `__${CXXBRIDGE_NAME}_generated` with properties
#   `INTERFACE_PRECOMPILE_HEADERS` and `INTERFACE_SOURCES` set to the `.h` and `.cc` files
#   generated by the `#[cxx::bridge]` module expansion.
#
function(cxxbridge)
  set(options)
  set(oneValueArgs NAME)
  set(multiValueArgs SOURCES)
  cmake_parse_arguments(CXXBRIDGE "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

  set(CXXBRIDGE_SOURCES_CC_OUT "")
  set(CXXBRIDGE_SOURCES_H_OUT "")
  foreach (bridge IN LISTS CXXBRIDGE_SOURCES)
    list(APPEND CXXBRIDGE_SOURCES_CC_OUT "${bridge}.cc")
    list(APPEND CXXBRIDGE_SOURCES_H_OUT "${bridge}.h")
  endforeach ()

  add_library(__${CXXBRIDGE_NAME}_generated INTERFACE)
  add_dependencies(__${CXXBRIDGE_NAME}_generated ${CXXBRIDGE_NAME}_h)
  set_target_properties(__${CXXBRIDGE_NAME}_generated PROPERTIES INTERFACE_PRECOMPILE_HEADERS "${CXXBRIDGE_SOURCES_H_OUT}")
  set_target_properties(__${CXXBRIDGE_NAME}_generated PROPERTIES INTERFACE_SOURCES "${CXXBRIDGE_SOURCES_CC_OUT}")

  set(${CXXBRIDGE_NAME}_SOURCES ${CXXBRIDGE_NAME_CC_OUT})
endfunction()

# Declares a Rust `staticlib` which exports the bindings of one or more `cxxbridge` crates.
#
# Preconditions:
#   A target `${OXIDIZE_NAME}_rs` invokes `cargo` to build the Rust crate.
#
# Inputs:
#   NAME oxidize_name
#   EXPORT cxxbridge1 cxxbridge2 ...
#
# Outputs:
#   A top-level target for a library `${OXIDIZE_NAME}_oxidize` which links with
#   `${OXIDIZE_NAME}_rs` and each of the `.cc` files generated by the associated
#   `#[cxx::bridge]` modules.
#   Header files are placed in `${TILEDB_OXIDIZE_INCLUDE_DIR}/${OXIDIZE_NAME}/tiledb/oxidize`
#   which is added to the include path of downstream targets which link with this library.
#   This enables C++ sources to use sanitized paths `#include "tiledb/oxidize/<bridge>.h"`.
#
function(oxidize)
  set(options)
  set(oneValueArgs NAME)
  set(multiValueArgs EXPORT)
  cmake_parse_arguments(OXIDIZE "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

  if (NOT OXIDIZE_NAME)
    message(SEND_ERROR "Function oxidize_bundle requires a NAME argument")
  endif ()

  if (NOT OXIDIZE_EXPORT)
    message(SEND_ERROR "Function oxidize_bundle requies EXPORT argument")
  endif ()

  set(OXIDIZE_STATICLIB "${OXIDIZE_NAME}_rs")
  set(OXIDIZE_INCLUDE_DIR "${TILEDB_OXIDIZE_INCLUDE_DIR}/${OXIDIZE_NAME}")

  set(OXIDIZE_EXPORT_H "")
  set(APPEND OXIDIZE_EXPORT_CC "")
  foreach (export ${OXIDIZE_EXPORT})
    set(export_generated_dir "${CORROSION_BUILD_DIR}/cxxbridge/tiledb-${export}/src")

    get_target_property(export_HEADERS __${export}_generated INTERFACE_PRECOMPILE_HEADERS)
    foreach (export_h ${export_HEADERS})
      if (${export_h} MATCHES "lib.rs.h")
        set(export_h_dst_relpath "${export}")
      elseif (${export_h} MATCHES "(.*)\/mod.rs.h")
        set(export_h_dst_relpath "${export}/${CMAKE_MATCH_1}")
      elseif (${export_h} MATCHES "(.*\/)*(.*).rs.h")
        set(export_h_dst_relpath "${export}/${CMAKE_MATCH_1}/${CMAKE_MATCH_2}")
      else ()
        message(SEND_ERROR "Unable to set 'bridge_dst': unexpected pattern in bridge file path: ${export_h}")
      endif ()

      set(export_h_dst "${OXIDIZE_INCLUDE_DIR}/tiledb/oxidize/${export_h_dst_relpath}.h")
      get_filename_component(export_h_dst_dirname ${export_h_dst} DIRECTORY)

      add_custom_command(
        OUTPUT
          "${export_h_dst}"
        COMMAND
          ${CMAKE_COMMAND} -E make_directory ${export_h_dst_dirname}
        COMMAND
          ${CMAKE_COMMAND} -E create_symlink ${export_generated_dir}/${export_h} ${export_h_dst}
        DEPENDS
          rust_h
          ${OXIDIZE_STATICLIB}
        WORKING_DIRECTORY
          ${CMAKE_CURRENT_BINARY_DIR}
      )

      list(APPEND OXIDIZE_EXPORT_H "${export_h_dst}")
    endforeach ()

    get_target_property(export_SOURCES __${export}_generated INTERFACE_SOURCES)
    foreach (export_cc ${export_SOURCES})
      set(export_cc_dst ${CORROSION_BUILD_DIR}/cxxbridge/tiledb-${export}/src/${export_cc})

      add_custom_command(
        OUTPUT
          "${export_cc_dst}"
        COMMAND
          ${CMAKE_COMMAND} -E echo "File '${export_cc}' is built by target '${OXIDIZE_STATICLIB}'."
        DEPENDS
          rust_h
          ${OXIDIZE_STATICLIB}
        WORKING_DIRECTORY
          ${CMAKE_CURRENT_BINARY_DIR}
      )

      list(APPEND OXIDIZE_EXPORT_CC ${export_cc_dst})
    endforeach ()
  endforeach ()

  add_custom_target(${OXIDIZE_NAME}_h DEPENDS ${OXIDIZE_EXPORT_H})
  add_custom_target(${OXIDIZE_NAME}_cc DEPENDS ${OXIDIZE_EXPORT_CC})

  set(OXIDIZE_LIB "${OXIDIZE_NAME}_oxidize")

  add_library(${OXIDIZE_LIB} OBJECT ${OXIDIZE_EXPORT_CC})
  add_dependencies(${OXIDIZE_LIB} ${OXIDIZE_NAME}_h rust_h ${OXIDIZE_NAME}_cc ${OXIDIZE_STATICLIB})
  target_include_directories(${OXIDIZE_LIB} PUBLIC ${CMAKE_SOURCE_DIR} ${TILEDB_OXIDIZE_INCLUDE_DIR} ${OXIDIZE_INCLUDE_DIR})
  target_link_libraries(${OXIDIZE_LIB} PUBLIC assert_header ${OXIDIZE_STATICLIB})
endfunction ()



# `make clean` cleans up all cargo output and sanitized include paths
set_property(DIRECTORY PROPERTY ADDITIONAL_MAKE_CLEAN_FILES ${CARGO_INCLUDE_DIR} ${TILEDB_OXIDIZE_INCLUDE_DIR})
