<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.55">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>fsm2</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../../../">
<link href="../../../../../../images/favicon.ico" rel="icon">
<script src="../../../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>
  body { padding: 0; margin: 1in; margin-right: 1in;  min-width: 8.5in; font-size: 11pt;}
  div.page-layout { height: 11in; width: 8.5in; margin 0; }
}
</style>


<link rel="stylesheet" href="../../../../../../quarto-materials/tiledb.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../../../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../../../../quarto-materials/tiledb-logo.png" alt="" class="navbar-logo">
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="https://tiledb.com"> 
<span class="menu-text">Home page</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://tiledb.com/contact"> 
<span class="menu-text">Contact us</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://github.com/TileDB-Inc/TileDB"> 
<span class="menu-text">Repo</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#analysis-of-port-state-machine" id="toc-analysis-of-port-state-machine" class="nav-link active" data-scroll-target="#analysis-of-port-state-machine">Analysis of Port State Machine</a>
  <ul class="collapse">
  <li><a href="#proof-outline" id="toc-proof-outline" class="nav-link" data-scroll-target="#proof-outline">Proof Outline</a>
  <ul class="collapse">
  <li><a href="#actions" id="toc-actions" class="nav-link" data-scroll-target="#actions">Actions</a></li>
  <li><a href="#source-proof-outline" id="toc-source-proof-outline" class="nav-link" data-scroll-target="#source-proof-outline">Source Proof Outline</a></li>
  <li><a href="#sink-proof-outline" id="toc-sink-proof-outline" class="nav-link" data-scroll-target="#sink-proof-outline">Sink Proof Outline</a></li>
  <li><a href="#comments" id="toc-comments" class="nav-link" data-scroll-target="#comments">Comments</a></li>
  </ul></li>
  <li><a href="#proof-outlines-for-buffered-edges-between-source-and-sink" id="toc-proof-outlines-for-buffered-edges-between-source-and-sink" class="nav-link" data-scroll-target="#proof-outlines-for-buffered-edges-between-source-and-sink">Proof Outlines for Buffered Edges Between Source and Sink</a>
  <ul class="collapse">
  <li><a href="#source-actions" id="toc-source-actions" class="nav-link" data-scroll-target="#source-actions">Source Actions</a></li>
  <li><a href="#sink-actions" id="toc-sink-actions" class="nav-link" data-scroll-target="#sink-actions">Sink Actions</a></li>
  <li><a href="#source-proof-outline-1" id="toc-source-proof-outline-1" class="nav-link" data-scroll-target="#source-proof-outline-1">Source Proof Outline</a></li>
  <li><a href="#sink-proof-outline-1" id="toc-sink-proof-outline-1" class="nav-link" data-scroll-target="#sink-proof-outline-1">Sink Proof Outline</a></li>
  <li><a href="#final-sink-proof-outline-1" id="toc-final-sink-proof-outline-1" class="nav-link" data-scroll-target="#final-sink-proof-outline-1">Final Sink Proof Outline</a></li>
  <li><a href="#comments-1" id="toc-comments-1" class="nav-link" data-scroll-target="#comments-1">Comments</a></li>
  </ul></li>
  <li><a href="#additional-alternative-proof-outlines-in-various-detail" id="toc-additional-alternative-proof-outlines-in-various-detail" class="nav-link" data-scroll-target="#additional-alternative-proof-outlines-in-various-detail">Additional, Alternative, Proof Outlines (In Various Detail)</a>
  <ul class="collapse">
  <li><a href="#source-proof-outline-2" id="toc-source-proof-outline-2" class="nav-link" data-scroll-target="#source-proof-outline-2">Source Proof Outline</a></li>
  <li><a href="#sink-proof-outline-2" id="toc-sink-proof-outline-2" class="nav-link" data-scroll-target="#sink-proof-outline-2">Sink Proof Outline</a></li>
  <li><a href="#summary-of-source-and-sink-proof-outline" id="toc-summary-of-source-and-sink-proof-outline" class="nav-link" data-scroll-target="#summary-of-source-and-sink-proof-outline">Summary of Source and Sink Proof Outline</a></li>
  <li><a href="#source-proof" id="toc-source-proof" class="nav-link" data-scroll-target="#source-proof">Source Proof</a></li>
  <li><a href="#sink-proof" id="toc-sink-proof" class="nav-link" data-scroll-target="#sink-proof">Sink Proof</a></li>
  <li><a href="#derivation-of-source-proof-with-concurrent-sink-actions" id="toc-derivation-of-source-proof-with-concurrent-sink-actions" class="nav-link" data-scroll-target="#derivation-of-source-proof-with-concurrent-sink-actions">Derivation of Source Proof with Concurrent Sink Actions</a></li>
  <li><a href="#derivation-of-sink-proof-with-concurrent-source-actions" id="toc-derivation-of-sink-proof-with-concurrent-source-actions" class="nav-link" data-scroll-target="#derivation-of-sink-proof-with-concurrent-source-actions">Derivation of Sink Proof with Concurrent Source Actions</a></li>
  <li><a href="#summary-of-final-source-and-sink-proof-outline" id="toc-summary-of-final-source-and-sink-proof-outline" class="nav-link" data-scroll-target="#summary-of-final-source-and-sink-proof-outline">Summary of Final Source and Sink Proof Outline</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">




<section id="analysis-of-port-state-machine" class="level1">
<h1>Analysis of Port State Machine</h1>
<p>The file fsm.h implements a state machine for two communicating ports, <code>Source</code> and <code>Sink</code>. Each port has two states, empty or full. There are two transition events associated with the source: fill, which transitions from empty to full and tells the state machine there is an item in the <code>Source</code>, and and push, which initiates transfer to the <code>Sink</code> and transitions from full to empty.</p>
<p>Similarly, there are two events associated with the sink: drain, which transitions from full to empty and tells the <code>Sink</code> node that its item has been removed, and and pull, which attempts to transfer an item from the <code>Source</code> and transitions from empty to full. For simplicity, though we may need them in the future, we not consider events for startup, stop, forced shutdown, or abort.</p>
<p>The following diagram shows the state transitions for the port state machine. The state is represented with two bits, one for the source and one for the sink, e.g., “00” meaning that the source state is 0 and the sink state is 1.</p>
<p><img src="two_stage.svg" class="img-fluid" alt="port state machine"><br>
</p>
<p>To provide the functionality of the state machine for the purposes of safely transferring data from a <code>Source</code> to a <code>Sink</code>, there are exit and entry actions associated with selected states and events.</p>
<p>One particular aspect of this is the pull event from state 00 and the push event from state 11. In these cases, the exit action is “wait”, since the only valid state to complete a push or a pull is from state 01. Accordingly, we perform notifications as entry actions to state 10.</p>
<p>When a source or sink thread is released from its wait, it is still in the push or pull event. To enable it to complete that desired operation, we restart the event processing for the push or pull event in the current state.</p>
<p>(As a slight optimization, we also perform notifications on entry to states 00 and 11. The waiter doesn’t get to move in that case, but does get to leave the wait and produce or consume an item and then try to push or pull again.)</p>
<p>Our basic goal for the <code>Source</code> and <code>Sink</code> ports is to transfer a data item from a <code>Source</code> to a connected (bound) <code>Sink</code>. At a high level, the way a client would use the <code>Source</code> to do this is the following: - create a data item - insert the data item into a <code>Source</code> port - invoke the fill event - invoke the push event</p>
<p>Similarly, the desired usage of a <code>Sink</code> port is also to transfer a data item from a <code>Source</code> to a bound <code>Sink</code>. At a high level, the way a client would use the <code>Source</code> is the following - invoke the pull event - extract the data item from the <code>Sink</code> port - consume the item - invoke the drain event</p>
<p>Based on these product states and the four above events, the state transition table for the product state machine (which we will just refer to as the “state machine” below is the following:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 11%">
<col style="width: 18%">
<col style="width: 18%">
<col style="width: 18%">
<col style="width: 18%">
<col style="width: 14%">
</colgroup>
<thead>
<tr class="header">
<th>State</th>
<th></th>
<th></th>
<th>Event</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td>fill</td>
<td>push</td>
<td>drain</td>
<td>pull</td>
<td>stop</td>
</tr>
<tr class="even">
<td>00</td>
<td>10</td>
<td>00</td>
<td></td>
<td>01</td>
<td></td>
</tr>
<tr class="odd">
<td>01</td>
<td>11</td>
<td>01</td>
<td>00</td>
<td>01</td>
<td></td>
</tr>
<tr class="even">
<td>10</td>
<td></td>
<td>01</td>
<td></td>
<td>01</td>
<td></td>
</tr>
<tr class="odd">
<td>11</td>
<td></td>
<td>01</td>
<td>10</td>
<td>11</td>
<td></td>
</tr>
</tbody>
</table>
<p>Using this table, we can include the states as predicates to create an initial “proof outline” statements for the <code>Source</code> operation:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>   <span class="cf">while</span> <span class="op">(</span>not done<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∨ state = 01 } ∧ { source_item = empty } */</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>     <span class="cf">do</span> produce and insert item</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∨ state = 01 } ∧ { source_item = full } */</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>     <span class="cf">do</span> fill</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 10 ∨ state = 11 } ∧ { source_item = full } */</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>     <span class="cf">do</span> push</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∨ state = 01 } ∧ { source_item = empty } */</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Similarly for <code>Sink</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>   <span class="cf">while</span> <span class="op">(</span>not done<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∨ state = 10 } ∧ { sink_item = empty } */</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>     <span class="cf">do</span> pull</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∨ state = 11 } ∧ { sink_item = full } */</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>     <span class="cf">do</span> extract and consume item  </span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∨ state = 11 } ∧ { sink_item = full } */</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>     <span class="cf">do</span> drain</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∨ state = 10 } ∧ { sink_item = empty } */</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Now, the <code>Source</code> and <code>Sink</code> need to coordinate <code>push</code> and <code>pull</code> so there is not a race condition (nor a deadlock) when making transitions in the state machine. Moreover, we have to make sensible transitions. That is, we only be able to succesfully do a push when the <code>Sink</code> state is empty (and the <code>Sink</code> item itself is empty). This is why we insert a new item and <em>then</em> invoke fill. Until the state has transitioned to indicate the state of the <code>Source</code> is full, the <code>Sink</code> will not attempt to transfer the item. Similarly, we empty the sink_item and <em>then</em> signal that the <code>Sink</code> is in the empty state.</p>
<p>To do this, we associate exit and entry actions with each state transition, some of which will synchronize between <code>Source</code> and <code>Sink</code>. These actions are used with the state transition thusly:</p>
<ul>
<li>begin_transition: given old_state and event</li>
<li>execute exit(old_state, event)</li>
<li>new_state = transition(old_state, event)</li>
<li>execute entry(new_state, event)</li>
</ul>
<p>Note that the exit action is called <em>before</em> the state transition. Note also that the entry action is called with the new state (the post transition state).</p>
<p>The tables for exit actions to be perfomed on state transitions is:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 11%">
<col style="width: 18%">
<col style="width: 18%">
<col style="width: 18%">
<col style="width: 18%">
<col style="width: 14%">
</colgroup>
<thead>
<tr class="header">
<th>State</th>
<th></th>
<th></th>
<th>Events</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td>fill</td>
<td>push</td>
<td>drain</td>
<td>pull</td>
<td>stop</td>
</tr>
<tr class="even">
<td>00</td>
<td></td>
<td>return</td>
<td></td>
<td>sink_wait</td>
<td></td>
</tr>
<tr class="odd">
<td>01</td>
<td></td>
<td>return</td>
<td></td>
<td>return</td>
<td></td>
</tr>
<tr class="even">
<td>10</td>
<td></td>
<td>source_swap</td>
<td></td>
<td>sink_swap</td>
<td></td>
</tr>
<tr class="odd">
<td>11</td>
<td></td>
<td>source_wait</td>
<td></td>
<td>return</td>
<td></td>
</tr>
</tbody>
</table>
<p>The table for entry actions to be performend on state transitions is:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 11%">
<col style="width: 18%">
<col style="width: 18%">
<col style="width: 20%">
<col style="width: 18%">
<col style="width: 13%">
</colgroup>
<thead>
<tr class="header">
<th>State</th>
<th></th>
<th></th>
<th>Events</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td>fill</td>
<td>push</td>
<td>drain</td>
<td>pull</td>
<td>shutdown</td>
</tr>
<tr class="even">
<td>00</td>
<td></td>
<td></td>
<td>notify_source</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>01</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>10</td>
<td>notify_sink</td>
<td></td>
<td>notify_source</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>11</td>
<td>notify_sink</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>The <code>source_swap</code> function is used to potentially transfer the data items associated with <code>Source</code> and <code>Sink</code> from the <code>Source</code> to the <code>Sink</code> (as well as changing the state if data transfer is carried out). The <code>source_swap</code> function is invoked whenever the state is 10 (which is when there is an item in <code>Source</code> and space available to transfer to the <code>Sink</code>. The data transfer is carried out by swapping the <code>Source</code> and <code>Sink</code> items and changing the state of 10 to 01.</p>
<p>When the state is 00, the <code>Sink</code> will wait for the <code>Source</code> to become full. The <code>Source</code> will notify the <code>Sink</code> when it becomes full. Similarly, if the state is 11, the <code>Source</code> will wait until it is signalled by the <code>Sink</code> that the <code>Sink</code> is empty.</p>
<section id="proof-outline" class="level2">
<h2 class="anchored" data-anchor-id="proof-outline">Proof Outline</h2>
<p>To prove correctness of the port state machine, we use proof outline techniques from e.g., <em>Concurrent Programming</em> by Greg Andrews. For this proof outline, we represent the overall state of a connected <code>Source</code> and <code>Sink</code> with two boolean arrays, each with two elements, shared by the <code>Source</code> and <code>Sink</code>: <code>state</code> and <code>items</code>.</p>
<section id="actions" class="level3">
<h3 class="anchored" data-anchor-id="actions">Actions</h3>
<p>For the purposes of a proof outline, the <code>Source</code> has three operations:</p>
<pre><code>1. inject: items[0] ← 1
2. fill: state[0] ← 1
3. push: 〈 await ¬{ state = 11 } :
            if { state = 10 ∧ items = 10 } → { state = 01 ∧ items = 01 } ⟩</code></pre>
<p>Similarly, for the purposes of a proof outline, the <code>Sink</code> has three operations:</p>
<pre><code>1. extract: item[1] ← 0
2. drain: state[1] ← 0
3. pull: 〈 await ¬{ state = 00 } :
            if { state = 10 ∧ items = 10 } → { state = 01 ∧ items = 01 } ⟩</code></pre>
</section>
<section id="source-proof-outline" class="level3">
<h3 class="anchored" data-anchor-id="source-proof-outline">Source Proof Outline</h3>
<p>The critical operation of the <code>Source</code> is the <code>push</code>, which blocks (awaits) until <code>¬{ state = 11 }</code>, that is, until the <code>state</code> is not equal to <code>11</code>. In that case, states 00, 01, and 10 could pass through. However, in addition to the await, <code>push</code> includes a data transfer step (a “move”) that will perform the following predicate transformation for <code>{ state = 10 }</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* { state = 10 ∧ items = 10 } → { state = 01 ∧ items = 01 } */</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This represents moving a data item from the <code>Source</code> to the <code>Sink</code>. Note that both the state machine <code>state</code> and the actual data items being held are (atomically) changed in the move.</p>
<p>Based on these properties of the <code>push</code>, we have the following valid states that can occur directly following a <code>push</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∧ items = 00 } ∨ */</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∧ items = 01 }   */</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>push</code> itself is atomic, but as soon as it has completed, the state of the port can be changed by the <code>Sink</code> operating asynchronously to the <code>Source</code>. Given the three operations that the <code>Sink</code> can perform, the above states can be subject to <code>pull</code>, <code>extract</code>, or <code>extract+drain</code>. The <code>pull</code> operation will not change the state. The <code>extract</code> operation can change <code>{ items = 01 }</code> to <code>{ items = 00 }</code>. Similarly, <code>drain</code> can change <code>{ state = 01 }</code> to <code>{ state = 00 }</code>. Note that <code>extract</code> always precedes <code>drain</code> – the <code>Sink</code> cannot change <code>{ state = 01 ∧ items = 01 }</code> into <code>{ state = 00 ∧ items = 01 }</code>.</p>
<p>Thus, the entire set of possible configurations following <code>push</code> are</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∧ items = 00 }                  ∨ */</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∧ ( items = 00 ∨ items = 01 ) }   */</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Following the <code>push</code>, the <code>Source</code> may <code>inject</code>, which will change the above states to:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∧ items = 10 }                  ∨ */</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∧ ( items = 11 ∨ items = 10 ) }   */</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Again, the <code>Sink</code> may <code>extract</code>, <code>drain</code>, or <code>pull</code>. However, the only change that can occur is that <code>extract</code> may change <code>{ items = 11 }</code> to <code>{ items = 10 }</code>, which is already part of the above configuration. A subsequent <code>drain</code> may then change<br>
<code>{ state = 01 ∧ items = 10 }</code> to <code>{ state = 00 ∧ items = 10 }</code>, which again, is already part of the above configuration. <strong>Thus, the <code>Sink</code> operating asynchronously will not change the system predicate between <code>inject</code> and <code>fill</code>.</strong> In other words, the sequence <code>inject</code> then <code>fill</code> can be considered to be atomic.</p>
<p>For the <code>fill</code> operation, the above predicate will be changed to</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 10 ∧ items = 10 }                  ∨ */</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 11 ∧ ( items = 11 ∨ items = 10 ) }   */</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Asynchronous operation of the <code>Sink</code> can change this predicate to</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∧ items = 00 }                  ∨ */</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∧ ( items = 00 ∨ items = 01 ) } ∨ */</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 10 ∧ items = 10 }                  ∨ */</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 11 ∧ ( items = 10 ∨ items = 11 ) }   */</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="final-source-proof-outline" class="level4">
<h4 class="anchored" data-anchor-id="final-source-proof-outline">Final Source Proof Outline</h4>
<p>Thus, the proof outline for the <code>Source</code> is</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>   <span class="cf">while</span> <span class="op">(</span>not done<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∧ items = 00 } ∨ { state = 01 ∧ ( items = 00 ∨ items = 01 ) }   */</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>     inject<span class="op">:</span> items<span class="op">[</span><span class="dv">0</span><span class="op">]</span> ← <span class="dv">1</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∧ items = 10 } ∨ { state = 01 ∧ ( items = 10 ∨ items = 11 ) }   */</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>     fill<span class="op">:</span> state<span class="op">[</span><span class="dv">0</span><span class="op">]</span> ← <span class="dv">1</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∧ items = 00 } ∨ { state = 01 ∧ ( items = 00 ∨ items = 01 ) } ∨ */</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 10 ∧ items = 10 } ∨ { state = 11 ∧ ( items = 10 ∨ items = 11 ) }   */</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>     push<span class="op">:</span> 〈 await ¬<span class="op">{</span> state <span class="op">=</span> <span class="dv">11</span> <span class="op">}</span> <span class="op">:</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>              <span class="cf">if</span> <span class="op">{</span> state <span class="op">=</span> <span class="dv">10</span> ∧ items <span class="op">=</span> <span class="dv">10</span> <span class="op">}</span> → <span class="op">{</span> state <span class="op">=</span> <span class="bn">01</span> ∧ items <span class="op">=</span> <span class="bn">01</span> <span class="op">}</span> ⟩</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∧ items = 00 } ∨ { state = 01 ∧ ( items = 00 ∨ items = 01 ) }   */</span>     </span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="sink-proof-outline" class="level3">
<h3 class="anchored" data-anchor-id="sink-proof-outline">Sink Proof Outline</h3>
<p>We can follow a similar process to derive the proof outline for the <code>Sink</code>.</p>
<p>The critical operation of the <code>Sink</code> is the <code>pull</code>, which blocks (awaits) until <code>¬{ state = 00 }</code>, that is, until the <code>state</code> is not equal to <code>00</code>. In that case, states 01, 10, and 11 could pass through. However, in addition to the await, <code>pull</code> includes a data transfer step (a “move”) that will perform the following predicate transformation for <code>{ state = 10 }</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* { state = 10 ∧ items = 10 } → { state = 01 ∧ items = 01 } */</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This represents moving a data item from the <code>Source</code> to the <code>Sink</code>. Note that both the state machine <code>state</code> and the actual data items being held are (atomically) changed in the move.</p>
<p>Based on these properties of the <code>push</code>, we have the following valide states that can occur directly following a <code>push</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∧ items = 01 } ∨ */</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 11 ∧ items = 11 }   */</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>pull</code> itself is atomic, but as soon as it has completed, the state of the port can be changed by the <code>Source</code> operating asynchronously to the <code>Sink</code>. Given the three operations that the <code>Source</code> can perform, the above states can be subject to <code>push</code>, <code>inject</code>, or <code>inject+fill</code>. The <code>push</code> operation will not change the predicate. The <code>inject</code> operation can change <code>{ items = 01 }</code> to <code>{ items = 11 }</code>. Similarly, <code>fill</code> can change <code>{ state = 01 }</code> to <code>{ state = 11 }</code>. Note that <code>inject</code> always precedes <code>fill</code> – the <code>Source</code> cannot change <code>{ state = 01 ∧ items = 01 }</code> into <code>{ state = 11 ∧ items = 01 }</code>.</p>
<p>Thus, the entire set of possible configurations following <code>push</code> are</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∧ ( items = 01 ∨ items = 11 ) } ∨ */</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 11 ∧ items = 11 }                    */</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Following the <code>pull</code>, the <code>Sink</code> may <code>extract</code>, which will change the above predicate to:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∧ ( items = 00 ∨ items = 10 ) } ∨ */</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 11 ∧ items = 10 }                    */</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Again, the <code>Source</code> may <code>inject</code>, <code>fill</code>, or <code>push</code>. However, the only change that can occur is that <code>inject</code> may change <code>{ items = 00 }</code> to <code>{ items = 10 }</code>, which is already part of the above configuration. A subsequent <code>fill</code> may then change<br>
<code>{ state = 01 ∧ items = 10 }</code> to <code>{ state = 11 ∧ items = 10 }</code>, which again, is already part of the above configuration. <strong>Thus, the <code>Source</code> operating asynchronously will not change the system predicate between <code>extract</code> and <code>drain</code>.</strong> In other words, the sequence <code>extract</code> then <code>drain</code> can be considered to be atomic.</p>
<p>For the <code>drain</code> operation, the above predicate will be changed to</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∧ ( items = 00 ∨ items = 10 ) } ∨ */</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 10 ∧ items = 10 }                    */</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Asynchronous operation of the <code>Source</code> can change this predicate to</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∧ ( items = 00 ∨ items = 10 ) } ∨ */</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 10 ∧ items = 10 }                  ∨ */</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∧ ( items = 01 ∨ items = 11 ) } ∨ */</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 11 ∧ items = 11 }                    */</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="final-sink-proof-outline" class="level4">
<h4 class="anchored" data-anchor-id="final-sink-proof-outline">Final Sink Proof Outline</h4>
<p>Thus, the complete <code>Sink</code> proof outline is</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>   <span class="cf">while</span> <span class="op">(</span>not done<span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∧ ( items = 00 ∨ items = 10 ) } ∨ { state = 10 ∧ items = 10 }   ∨ */</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∧ ( items = 01 ∨ items = 11 ) } ∨ { state = 11 ∧ items = 11 }     */</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>     pull<span class="op">:</span> 〈 await ¬<span class="op">{</span> state <span class="op">=</span> <span class="bn">00</span> <span class="op">}</span> <span class="op">:</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>              <span class="cf">if</span> <span class="op">{</span> state <span class="op">=</span> <span class="dv">10</span> ∧ items <span class="op">=</span> <span class="dv">10</span> <span class="op">}</span> → <span class="op">{</span> state <span class="op">=</span> <span class="bn">01</span> ∧ items <span class="op">=</span> <span class="bn">01</span> <span class="op">}</span> ⟩</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∧ ( items = 01 ∨ items = 11 ) } ∨ { state = 11 ∧ items = 11 ) }   */</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>     extract<span class="op">:</span> extract<span class="op">:</span> item<span class="op">[</span><span class="dv">1</span><span class="op">]</span> ← <span class="dv">0</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∧ ( items = 00 ∨ items = 10 ) } ∨ { state = 11 ∧ items = 01 ) }   */</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>     drain<span class="op">:</span> state<span class="op">[</span><span class="dv">1</span><span class="op">]</span> ← <span class="dv">0</span>  </span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∧ ( items = 00 ∨ items = 10 ) } ∨ { state = 10 ∧ items = 10 }   ∨ */</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∧ ( items = 01 ∨ items = 11 ) } ∨ { state = 11 ∧ items = 11 ) }   */</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="comments" class="level3">
<h3 class="anchored" data-anchor-id="comments">Comments</h3>
<p>The proof outlines shows some important characteristics of the port state machine.</p>
<ol type="1">
<li>If we begin with the valid state <code>{ state = 00 ∧ items = 00 }</code> (which is the only sensible state with which to begin), the state machine will never enter any <code>BAD</code> state. We define a <code>BAD</code> state to be any of the following:</li>
</ol>
<ul>
<li>predicate with <code>{ items = 10 ∨ items = 11 }</code> prior to <code>inject</code></li>
<li>predicate with <code>{ state = 10 ∨ state = 11 }</code> prior to <code>fill</code></li>
<li>predicate with <code>{ items = 00 ∨ items = 10 }</code> prior to <code>extract</code></li>
<li>predicate with <code>{ state = 00 ∨ state = 10 }</code> prior to <code>drain</code></li>
</ul>
<ol start="2" type="1">
<li><p>If we begin with the valid state <code>{ state = 00 ∧ items = 00 }</code>, and use the following steps for the <code>Source</code></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>  inject</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  fill</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  push</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>Source</code> will <strong>always</strong> be ready to accept an item for injection. Hence we do not have to check whether the <code>Source</code> is ready prior to invoking <code>inject</code>. No concurrent <code>Sink</code> action will change the state into one that is <code>BAD</code> prior to <code>inject</code>.</p></li>
<li><p>Similarly, if we use the following steps for the <code>Sink</code></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>  pull</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  extract</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  drain</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>There will <strong>always</strong> be an item ready to extract after <code>pull</code> completes.</p></li>
<li><p>There are no race conditions between <code>inject</code> and <code>fill</code>, nor between <code>extract</code> and <code>drain</code>. Concurrent actions from the <code>Sink</code> cannot cause a <code>BAD</code> state between <code>inject</code> and <code>fill</code>, nor can concurrent actions from the <code>Source</code> introduce a <code>BAD</code> state between <code>extract</code> and <code>drain</code>.</p></li>
<li><p>In fact, there are no race conditions between <strong>any</strong> of the steps in the <code>Source</code> or the <code>Sink</code>. As a result, we do not need to introduce any locking mechanism to make any pairs of actions atomic. (As a reminder, all actions executed by the state machine are atomic.)</p></li>
<li><p>Operations carried out directly by the state machine are protected by a lock. When the <code>Source</code> or <code>Sink</code> wait, they do so on a condition variable using that same lock. Note that when the <code>Source</code> and <code>Sink</code> both exit their loops that the <code>Source</code> will have { state = 00 ∨ state = 01 } while the <code>Sink</code> will have { state = 00 ∨ state = 10 }. The final state of the state machine is therefore { state = 00 ∨ state = 01 } ∧ { state = 00 ∨ state = 10 } ∧ { item = empty }, i.e., { state = 00 } ∧ { item = empty }. (This assumes that both <code>Source</code> and <code>Sink</code> perform the same number of operations, otherwise one of them will be left in a wait.)</p></li>
<li><p><strong>NB:</strong> The “move” portion of <code>push</code> and the “move” portion of <code>pull</code> (<code>source_swap</code> and <code>sink_swap</code>, respectively). Each checks to see if the state is equal to 10, if so, they swap the state to 01 (and perform a swap of the items associated with the source and sink), and notifies the other. If the state is not equal to 10, the swap function notifies the other and goes into a wait. Thus, we may not need separate swaps for <code>Source</code> and <code>Sink</code>, nor separate condition variables, nor separate notification functions. I have verified that this works experimentally, but I am leaving things separate for now.</p></li>
</ol>
</section>
</section>
<section id="proof-outlines-for-buffered-edges-between-source-and-sink" class="level2">
<h2 class="anchored" data-anchor-id="proof-outlines-for-buffered-edges-between-source-and-sink">Proof Outlines for Buffered Edges Between Source and Sink</h2>
<p>For much of what TileDB will be doing with our task graph library, we will be using multi-stage edges between nodes. <code>Edge</code>s, as they are currently implemented, still provide a control connection from the <code>Sink</code> to the <code>Source</code> connected by the <code>Edge</code>. In developing a proof outline for <code>Source</code> and <code>Sink</code> connected by an <code>Edge</code> with one (or more) buffered stages, we must account for the buffered data in both the <code>state</code> and the <code>items</code>.</p>
<p>We can follow a similar development for thi proof outline as we did for the unbuffered case.</p>
<p>Revisiting the <code>Source</code> and <code>Sink</code> operations that we previously presented, we have the following actions for a three-stage port state machine:</p>
<section id="source-actions" class="level3">
<h3 class="anchored" data-anchor-id="source-actions">Source Actions</h3>
<pre><code>1. inject: items[0] ← 1
2. fill: state[0] ← 1
3. push: 〈 await ¬{ state = 111 } :
            if { state = 010 ∧ items = 010 } → { state = 001 ∧ items = 001 } ⟩
            if { state = 100 ∧ items = 100 } → { state = 001 ∧ items = 001 } ⟩
            if { state = 101 ∧ items = 101 } → { state = 011 ∧ items = 011 } ⟩
            if { state = 110 ∧ items = 110 } → { state = 011 ∧ items = 011 } ⟩</code></pre>
</section>
<section id="sink-actions" class="level3">
<h3 class="anchored" data-anchor-id="sink-actions">Sink Actions</h3>
<p>Similarly, for the purposes of a proof outline, the <code>Sink</code> has three operations:</p>
<pre><code>1. extract: item[2] ← 0
2. drain: state[2] ← 0
3. pull: 〈 await ¬{ state = 000 } :
            if { state = 010 ∧ items = 010 } → { state = 001 ∧ items = 001 } ⟩
            if { state = 100 ∧ items = 100 } → { state = 001 ∧ items = 001 } ⟩
            if { state = 101 ∧ items = 101 } → { state = 011 ∧ items = 011 } ⟩
            if { state = 110 ∧ items = 110 } → { state = 011 ∧ items = 011 } ⟩</code></pre>
</section>
<section id="source-proof-outline-1" class="level3">
<h3 class="anchored" data-anchor-id="source-proof-outline-1">Source Proof Outline</h3>
<p>Consider first the effect of the <code>push</code> operation. Given the await condition, the state of the system must be <code>¬{ state = 111 }</code>. Moreover, the push operation includes a “move” operation such that there are no “holes” in the data being transferred. That is, immediately after the (atomic) push operation completes, we have</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 000 ∧ items = 000 } ∨ */</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 001 ∧ items = 001 } ∨ */</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 011 ∧ items = 011 }   */</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Actions from the asynchronous <code>Sink</code> can then occur, i.e., an extract, drain, and/or pull.<br>
Given the operations shown above, we can see that the predicate</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 001 ∧ items = 001 } */</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>can become</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 001 ∧ ( items = 001 ∨ 000 } */</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>if an extract occurs. A drain may then cause <code>{ state = 001 }</code> to become <code>{ state = 000 }</code>. But note that a drain can only follow an extract, so the predicate</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 000 ∧ items = 001 } */</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>cannot occur. Applying the possible occurrences of extract-drain-pull, we have the following potential predicate that can occur due to an asynchronous <code>Sink</code> following the <code>Source</code> push:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 000 ∧ items = 000 }                   ∨ */</span> </span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 001 ∧ ( items = 001 ∨ items = 000 ) } ∨ */</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 010 ∧ items = 010 }                   ∨ */</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 011 ∧ ( items = 011 ∨ items = 010 ) }   */</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This is a “stable” predicate, meaning there are no other possible states that could occur due to asynchronous <code>Sink</code> actions.</p>
<section id="final-source-proof-outline-1" class="level4">
<h4 class="anchored" data-anchor-id="final-source-proof-outline-1">Final Source Proof Outline</h4>
<p>The final state of the push operation will also be the initial state prior to <code>inject</code>. If we begin there and apply the state changes that would be caused by <code>inject</code> and <code>fill</code> (along with the asynchronous <code>Sink</code>), we arrive at the following complete proof outline for the <code>Source</code>:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>   <span class="cf">while</span> <span class="op">(</span>not done<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 000 ∧ items = 000 }                   ∨ */</span> </span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 001 ∧ ( items = 001 ∨ items = 000 ) } ∨ */</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 010 ∧ items = 010 }                   ∨ */</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 011 ∧ ( items = 011 ∨ items = 010 ) }   */</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>     inject<span class="op">:</span> items<span class="op">[</span><span class="dv">0</span><span class="op">]</span> ← <span class="dv">1</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 000 ∧ items = 100 }                   ∨ */</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 001 ∧ ( items = 101 ∨ items = 100 ) } ∨ */</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 010 ∧ items = 110 }                   ∨ */</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 011 ∧ ( items = 111 ∨ items = 110 ) }   */</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>     fill<span class="op">:</span> state<span class="op">[</span><span class="dv">0</span><span class="op">]</span> ← <span class="dv">1</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 000 ∧ items = 000 }                   ∨ */</span> </span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 001 ∧ ( items = 001 ∨ items = 000 ) } ∨ */</span></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 010 ∧ items = 010 }                   ∨ */</span></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 011 ∧ ( items = 011 ∨ items = 010 ) } ∨ */</span></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 100 ∧ items = 100 }                   ∨ */</span> </span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 101 ∧ ( items = 101 ∨ items = 100 ) } ∨ */</span></span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 110 ∧ items = 110 }                   ∨ */</span></span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 111 ∧ ( items = 111 ∨ items = 110 ) }   */</span></span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a>     push<span class="op">:</span> 〈 await ¬<span class="op">{</span> state <span class="op">=</span> <span class="dv">111</span> <span class="op">}</span> </span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-27"><a href="#cb28-27" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 000 ∧ items = 000 }                   ∨ */</span> </span>
<span id="cb28-28"><a href="#cb28-28" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 001 ∧ ( items = 001 ∨ items = 000 ) } ∨ */</span></span>
<span id="cb28-29"><a href="#cb28-29" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 010 ∧ items = 010 }                   ∨ */</span></span>
<span id="cb28-30"><a href="#cb28-30" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 011 ∧ ( items = 011 ∨ items = 010 ) }   */</span></span>
<span id="cb28-31"><a href="#cb28-31" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="sink-proof-outline-1" class="level3">
<h3 class="anchored" data-anchor-id="sink-proof-outline-1">Sink Proof Outline</h3>
<p>We can apply a similar process to derive the <code>Sink</code> proof outline. In this case, we begin with the system state immediately following the pull operation, which is <code>¬{ state = 000 }</code>. The pull operation will also move the items, in similar fashion to push above, i.e.:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 001 ∧ items = 001 } ∨ */</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 011 ∧ items = 011 } ∨ */</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 111 ∧ items = 111 }   */</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Now we consider the changes to this state that may occur due to asynchronous operation of the <code>Source</code>, i.e., inject, fill, and/or push. Given the operations shown above, we can see that the predicate</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 001 ∧ items = 001 } */</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>can become</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 001 ∧ ( items = 001 ∨ items = 101 } */</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>if an inject occurs.<br>
A fill will cause <code>{ state = 001 }</code> to become <code>{ state = 101 }</code>. But note that a fill can only follow an inject, so the predicate</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 101 ∧ items = 001 } */</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>cannot occur. Applying the possible occurrences of inject-fill-push, we have the following potential states that can occur due to an asynchronous <code>Source</code> following the <code>Sink</code> pull:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 001 ∧ ( items = 001 ∨ items = 101 ) } ∨ */</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 011 ∧ ( items = 011 ∨ items = 111 ) } ∨ */</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 101 ∧ items = 101 }                   ∨ */</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 111 ∧ items = 111 }                     */</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>These are stable states, meaning there are no other possible states that could occur due to the <code>Source</code>.</p>
</section>
<section id="final-sink-proof-outline-1" class="level3">
<h3 class="anchored" data-anchor-id="final-sink-proof-outline-1">Final Sink Proof Outline</h3>
<p>Evolving the states from there based on operations of the <code>Sink</code> and taking into account asynchronous operations of the <code>Source</code> we obtain the following proof outline:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>   <span class="cf">while</span> <span class="op">(</span>not done<span class="op">)</span> <span class="op">{</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 000 ∧ ( items = 000 ∨ items = 100 ) } ∨ */</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 001 ∧ ( items = 001 ∨ items = 101 ) } ∨ */</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 010 ∧ ( items = 010 ∨ items = 110 ) } ∨ */</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 011 ∧ ( items = 011 ∨ items = 111 ) } ∨ */</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 100 ∧ items = 100 }                   ∨ */</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 101 ∧ items = 101 }                   ∨ */</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 110 ∧ items = 110 }                   ∨ */</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 111 ∧ items = 111 }                     */</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>     pull<span class="op">:</span> 〈 await ¬<span class="op">{</span> state <span class="op">=</span> <span class="bn">000</span> <span class="op">}</span> <span class="op">:</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 001 ∧ ( items = 001 ∨ items = 101 ) } ∨ */</span></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 011 ∧ ( items = 011 ∨ items = 111 ) } ∨ */</span></span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 101 ∧ items = 101 }                   ∨ */</span></span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 111 ∧ items = 111 }                     */</span></span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a>     extract<span class="op">:</span> extract<span class="op">:</span> item<span class="op">[</span><span class="dv">2</span><span class="op">]</span> ← <span class="dv">0</span></span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 001 ∧ ( items = 000 ∨ items = 100 ) } ∨ */</span></span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 011 ∧ ( items = 010 ∨ items = 110 ) } ∨ */</span></span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 101 ∧ items = 100 }                   ∨ */</span></span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 111 ∧ items = 110 }                     */</span></span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true" tabindex="-1"></a>     drain<span class="op">:</span> state<span class="op">[</span><span class="dv">2</span><span class="op">]</span> ← <span class="dv">0</span></span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-28"><a href="#cb34-28" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 000 ∧ ( items = 000 ∨ items = 100 ) } ∨ */</span></span>
<span id="cb34-29"><a href="#cb34-29" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 001 ∧ ( items = 001 ∨ items = 101 ) } ∨ */</span></span>
<span id="cb34-30"><a href="#cb34-30" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 010 ∧ ( items = 010 ∨ items = 110 ) } ∨ */</span></span>
<span id="cb34-31"><a href="#cb34-31" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 011 ∧ ( items = 011 ∨ items = 111 ) } ∨ */</span></span>
<span id="cb34-32"><a href="#cb34-32" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 100 ∧ items = 100 }                   ∨ */</span></span>
<span id="cb34-33"><a href="#cb34-33" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 101 ∧ items = 101 }                   ∨ */</span></span>
<span id="cb34-34"><a href="#cb34-34" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 110 ∧ items = 110 }                   ∨ */</span></span>
<span id="cb34-35"><a href="#cb34-35" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 111 ∧ items = 111 }                     */</span></span>
<span id="cb34-36"><a href="#cb34-36" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="comments-1" class="level3">
<h3 class="anchored" data-anchor-id="comments-1">Comments</h3>
<p>As with the unbuffered case, the the buffered proof outlines shows the same important characteristics of the port state machine.</p>
<ol type="1">
<li>If we begin with the valid state <code>{ state = 000 ∧ items = 000 }</code> (which is the only sensible state with which to begin), the state machine will never enter any <code>BAD</code> state. We define a <code>BAD</code> state to be any of the following:</li>
</ol>
<ul>
<li>predicate with <code>{ items = 1x0 ∨ items = 1x1 }</code> prior to <code>inject</code></li>
<li>predicate with <code>{ state = 1x0 ∨ state = 1x1 }</code> prior to <code>fill</code></li>
<li>predicate with <code>{ items = 0x0 ∨ items = 1x0 }</code> prior to <code>extract</code></li>
<li>predicate with <code>{ state = 0x0 ∨ state = 1x0 }</code> prior to <code>drain</code></li>
</ul>
<ol start="2" type="1">
<li><p>If we begin with the valid state <code>{ state = 000 ∧ items = 000 }</code>, and use the following steps for the <code>Source</code></p>
<div class="sourceCode" id="cb35"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>  inject</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  fill</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>  push</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>Source</code> will <strong>always</strong> be ready to accept an item for injection. Hence we do not have to check whether the <code>Source</code> is ready prior to invoking <code>inject</code>. No concurrent <code>Sink</code> action will change the state into one that is <code>BAD</code> prior to <code>inject</code>.</p></li>
<li><p>Similarly, if we begin with the valid state <code>{ state = 000 ∧ items = 000 }</code> and use the following steps for the <code>Sink</code></p>
<div class="sourceCode" id="cb36"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>  pull</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>  extract</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>  drain</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>There will <strong>always</strong> be an item ready to extract after <code>pull</code> completes.</p></li>
<li><p>There are no race conditions between <code>inject</code> and <code>fill</code>, nor between <code>extract</code> and <code>drain</code>. Concurrent actions from the <code>Sink</code> cannot cause a <code>BAD</code> state between <code>inject</code> and <code>fill</code>, nor can concurrent actions from the <code>Source</code> introduce a <code>BAD</code> state between <code>extract</code> and <code>drain</code>.</p></li>
<li><p>In fact, there are no race conditions between <strong>any</strong> of the steps in the <code>Source</code> or the <code>Sink</code>. As a result, we do not need to introduce any locking mechanism to make any pairs of actions atomic. (As a reminder, all actions executed by the state machine are atomic.)</p></li>
</ol>
</section>
</section>
<section id="additional-alternative-proof-outlines-in-various-detail" class="level2">
<h2 class="anchored" data-anchor-id="additional-alternative-proof-outlines-in-various-detail">Additional, Alternative, Proof Outlines (In Various Detail)</h2>
<section id="source-proof-outline-2" class="level3">
<h3 class="anchored" data-anchor-id="source-proof-outline-2">Source Proof Outline</h3>
<p>In more detail, we can describe the <code>Source</code> behavior (including proof outline predicates). The steps of <code>Source</code> operation are pseudocode in normal text, while the associated state of the state machine are given in comments, with predicates in curly braces.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>  init<span class="op">:</span> <span class="co">/* { state = 00 ∧ source_item = empty } */</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>not done<span class="op">)</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∨ state = 01 } ∧ { source_item = empty } */</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>     client of the source inserts an item  <span class="co">/* Note that although the Sink can execute and potentially change the</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a><span class="co">                                              state here, the allowable transitions do not end up changing it */</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∨ state = 01 } ∧ { source_item = full } */</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>     client invokes fill event to transition from empty to full<span class="op">.</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>     state machine locks mutex</span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { mutex = locked } */</span></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>     state machine invokes exit action</span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a>     <span class="cf">if</span> <span class="op">{</span> state <span class="op">=</span> <span class="bn">00</span> ∨ state <span class="op">=</span> <span class="bn">01</span> <span class="op">}</span> → none</span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∨ state = 01 } ∧ { source_item = full } */</span></span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a>     state machine performs transition</span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 } → { state = 10 } ∧ { source_item = full } */</span></span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 } → { state = 11 } ∧ { source_item = full } */</span></span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 10 ∨ state = 11 } ∧ { source_item = full } */</span></span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true" tabindex="-1"></a>     Source notifies Sink that it is full</span>
<span id="cb37-22"><a href="#cb37-22" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 10 ∨ state = 11 } ∧ { source_item = full } */</span></span>
<span id="cb37-23"><a href="#cb37-23" aria-hidden="true" tabindex="-1"></a>     Source returns</span>
<span id="cb37-24"><a href="#cb37-24" aria-hidden="true" tabindex="-1"></a>     state machine unlocks mutex</span>
<span id="cb37-25"><a href="#cb37-25" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { mutex = unlocked } */</span></span>
<span id="cb37-26"><a href="#cb37-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-27"><a href="#cb37-27" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* Before the Source begins the push, the Sink may pull, drain, do both, or do nothing */</span></span>
<span id="cb37-28"><a href="#cb37-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-29"><a href="#cb37-29" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 10 ∨ state = 11 ∨ state = 01 ∨ state = 00 } ∧ { source_item = empty ∨ source_item = full } */</span></span>
<span id="cb37-30"><a href="#cb37-30" aria-hidden="true" tabindex="-1"></a>     client invokes push event</span>
<span id="cb37-31"><a href="#cb37-31" aria-hidden="true" tabindex="-1"></a>     state machine locks the mutex</span>
<span id="cb37-32"><a href="#cb37-32" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { mutex = locked */</span></span>
<span id="cb37-33"><a href="#cb37-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-34"><a href="#cb37-34" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 10 ∨ state = 11 ∨ state = 01 ∨ state = 00 } ∧ { source_item = empty ∨ source_item = full } */</span></span>
<span id="cb37-35"><a href="#cb37-35" aria-hidden="true" tabindex="-1"></a>     state machine executes push exit action<span class="op">,</span> which may be one of the following<span class="op">,</span> depending on the state</span>
<span id="cb37-36"><a href="#cb37-36" aria-hidden="true" tabindex="-1"></a>     restart<span class="op">:</span></span>
<span id="cb37-37"><a href="#cb37-37" aria-hidden="true" tabindex="-1"></a>       <span class="cf">if</span> <span class="op">{</span> state <span class="op">=</span> <span class="bn">00</span> ∨ state <span class="op">=</span> <span class="bn">01</span> <span class="op">}</span> → none</span>
<span id="cb37-38"><a href="#cb37-38" aria-hidden="true" tabindex="-1"></a>       <span class="cf">if</span> state <span class="op">=</span> <span class="dv">10</span> → execute source_swap</span>
<span id="cb37-39"><a href="#cb37-39" aria-hidden="true" tabindex="-1"></a>       <span class="cf">if</span> state <span class="op">=</span> <span class="dv">11</span> → execute source_wait</span>
<span id="cb37-40"><a href="#cb37-40" aria-hidden="true" tabindex="-1"></a>         pre_source_swap<span class="op">:</span> <span class="co">/* { state = 10 } ∧ { source_item = full } */</span></span>
<span id="cb37-41"><a href="#cb37-41" aria-hidden="true" tabindex="-1"></a>            state machine swaps source_item and sink_item <span class="op">--</span> swap does not change state</span>
<span id="cb37-42"><a href="#cb37-42" aria-hidden="true" tabindex="-1"></a>         post_source_swap<span class="op">:</span> <span class="co">/* { state = 10 } ∧ { source_item = empty } */</span></span>
<span id="cb37-43"><a href="#cb37-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-44"><a href="#cb37-44" aria-hidden="true" tabindex="-1"></a>       <span class="cf">if</span> <span class="op">{</span> state <span class="op">=</span> <span class="dv">11</span> <span class="op">}</span> → execute source_wait  </span>
<span id="cb37-45"><a href="#cb37-45" aria-hidden="true" tabindex="-1"></a>          pre_source_wait<span class="op">:</span> <span class="co">/* { state = 11 } */</span></span>
<span id="cb37-46"><a href="#cb37-46" aria-hidden="true" tabindex="-1"></a>          <span class="co">/* unlock mutex and wait for Sink to become empty */</span></span>
<span id="cb37-47"><a href="#cb37-47" aria-hidden="true" tabindex="-1"></a>          <span class="co">/* Important! When the state machine comes back from wait, it is now no longer in the state it was when it started the wait. */</span></span>
<span id="cb37-48"><a href="#cb37-48" aria-hidden="true" tabindex="-1"></a>          <span class="co">/* We therefore restart event processing for the push event, given the state present when coming back from wait: goto restart.*/</span></span>
<span id="cb37-49"><a href="#cb37-49" aria-hidden="true" tabindex="-1"></a>       <span class="co">/* { mutex = locked } */</span></span>
<span id="cb37-50"><a href="#cb37-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-51"><a href="#cb37-51" aria-hidden="true" tabindex="-1"></a>       <span class="co">/* { state = 00 ∨ state = 01 ∨ state = 10 } ∧ { source_item = empty } */</span>      </span>
<span id="cb37-52"><a href="#cb37-52" aria-hidden="true" tabindex="-1"></a>       make state transition according to state transition table and next_state set by most recent event</span>
<span id="cb37-53"><a href="#cb37-53" aria-hidden="true" tabindex="-1"></a>         <span class="op">{</span> state <span class="op">=</span> <span class="bn">00</span> <span class="op">}</span> → <span class="op">{</span> state <span class="op">=</span> <span class="bn">00</span> <span class="op">}</span></span>
<span id="cb37-54"><a href="#cb37-54" aria-hidden="true" tabindex="-1"></a>         <span class="op">{</span> state <span class="op">=</span> <span class="bn">01</span> ∨ state <span class="op">=</span> <span class="dv">10</span> <span class="op">}</span> → <span class="op">{</span> state <span class="op">=</span> <span class="bn">01</span> <span class="op">}</span></span>
<span id="cb37-55"><a href="#cb37-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-56"><a href="#cb37-56" aria-hidden="true" tabindex="-1"></a>       <span class="co">/* { state = 00 ∨ state = 01 } ∧ { source_item = empty } */</span></span>
<span id="cb37-57"><a href="#cb37-57" aria-hidden="true" tabindex="-1"></a>       state machine invokes entry action <span class="op">(</span>none<span class="op">)</span> </span>
<span id="cb37-58"><a href="#cb37-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-59"><a href="#cb37-59" aria-hidden="true" tabindex="-1"></a>       post_entry<span class="op">:</span> <span class="co">/* { state = 00 ∨ state = 01 } ∧ { source_item = empty } */</span></span>
<span id="cb37-60"><a href="#cb37-60" aria-hidden="true" tabindex="-1"></a>       state machine unlocks mutex</span>
<span id="cb37-61"><a href="#cb37-61" aria-hidden="true" tabindex="-1"></a>       <span class="co">/* { mutex = unlocked } */</span></span>
<span id="cb37-62"><a href="#cb37-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-63"><a href="#cb37-63" aria-hidden="true" tabindex="-1"></a>      post_push<span class="op">:</span> <span class="co">/* { state = 00 ∨ state = 01 } ∧ { source_item = empty } */</span></span>
<span id="cb37-64"><a href="#cb37-64" aria-hidden="true" tabindex="-1"></a>    end_loop<span class="op">:</span> <span class="co">/* { state = 00 ∨ state = 01 } ∧ { source_item = empty } */</span></span>
<span id="cb37-65"><a href="#cb37-65" aria-hidden="true" tabindex="-1"></a>  post_loop<span class="op">:</span> <span class="co">/* { state = 00 ∨ state = 01 } ∧ { source_item = empty } */</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="sink-proof-outline-2" class="level3">
<h3 class="anchored" data-anchor-id="sink-proof-outline-2">Sink Proof Outline</h3>
<p>The <code>Sink</code> is the dual of the Source. Note that we start with pull. We can describe the <code>Sink</code> behavior (including proof outline predicates):</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>  init<span class="op">:</span> <span class="co">/* { state = 00 ∧ sink_item = empty } */</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>not done<span class="op">)</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∨ state = 01 } ∧ { sink_item = empty ∨ sink_item = full } */</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* Before client invokes the pull event, the source could have filled, filled and pushed, or done nothing */</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>       <span class="cf">if</span> source filled<span class="op">:</span> <span class="bn">00</span> → <span class="dv">10</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>       <span class="cf">if</span> source filled and pushed <span class="bn">00</span> → <span class="bn">01</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>       <span class="cf">if</span> source filled and pushed and filled <span class="bn">00</span> → <span class="dv">11</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>       <span class="cf">if</span> source did nothing state does not change</span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∨ state = 01 ∨ state = 10 ∨ state = 10 } ∧ { sink_item = empty ∨ sink_item = full } */</span></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>     client invokes pull event</span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>     state machine locks mutex</span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* mutex = locked */</span></span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∨ state = 01 ∨ state = 10 ∨ state = 11 } ∧ { sink_item = empty ∨ sink_item = full } */</span></span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a>     state machine executes pull exit action<span class="op">,</span> which may be one of the following<span class="op">,</span> depending on the state</span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a>     restart<span class="op">:</span></span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a>       <span class="op">{</span> state <span class="op">=</span> <span class="bn">01</span> ∨ state <span class="op">=</span> <span class="dv">11</span> <span class="op">}</span> → none</span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a>       <span class="op">{</span> state <span class="op">=</span> <span class="dv">10</span> <span class="op">}</span> → sink_swap </span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a>       <span class="op">{</span> state <span class="op">=</span> <span class="bn">00</span> <span class="op">}</span> → sink_wait</span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a>         pre_sink_swap<span class="op">:</span> <span class="co">/* { state = 10 } ∧ { sink_item = empty } */</span></span>
<span id="cb38-21"><a href="#cb38-21" aria-hidden="true" tabindex="-1"></a>         post_sink_swap<span class="op">:</span> <span class="co">/* { state = 10 } ∧ { sink_item = full } */</span></span>
<span id="cb38-22"><a href="#cb38-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-23"><a href="#cb38-23" aria-hidden="true" tabindex="-1"></a>         <span class="cf">if</span> <span class="op">{</span> state <span class="op">=</span> <span class="bn">00</span> <span class="op">}</span> → execute sink_wait</span>
<span id="cb38-24"><a href="#cb38-24" aria-hidden="true" tabindex="-1"></a>         pre_sink_wait<span class="op">:</span> <span class="co">/* { state = 00 } */</span> </span>
<span id="cb38-25"><a href="#cb38-25" aria-hidden="true" tabindex="-1"></a>           <span class="co">/* unlock mutex and wait for Source to become full */</span></span>
<span id="cb38-26"><a href="#cb38-26" aria-hidden="true" tabindex="-1"></a>           <span class="co">/* Important! When the state machine comes back from wait, it is now no longer in the state it was when it started the wait. */</span></span>
<span id="cb38-27"><a href="#cb38-27" aria-hidden="true" tabindex="-1"></a>           <span class="co">/* We therefore restart event processing for the pull event, given the state present when coming back from wait: goto restart.*/</span></span>
<span id="cb38-28"><a href="#cb38-28" aria-hidden="true" tabindex="-1"></a>       <span class="co">/* { mutex = locked */</span></span>
<span id="cb38-29"><a href="#cb38-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-30"><a href="#cb38-30" aria-hidden="true" tabindex="-1"></a>       <span class="co">/* { state = 01 ∨ state = 10 ∨ state = 11 } ∧ { sink_item = full } */</span>      </span>
<span id="cb38-31"><a href="#cb38-31" aria-hidden="true" tabindex="-1"></a>       make state transition according to state transition table and state and next_state set by most recent event</span>
<span id="cb38-32"><a href="#cb38-32" aria-hidden="true" tabindex="-1"></a>         <span class="op">{</span> state <span class="op">=</span> <span class="bn">01</span> ∨ state <span class="op">=</span> <span class="dv">10</span> <span class="op">}</span> → <span class="op">{</span> state <span class="op">=</span> <span class="bn">01</span> <span class="op">}</span></span>
<span id="cb38-33"><a href="#cb38-33" aria-hidden="true" tabindex="-1"></a>         <span class="op">{</span> state <span class="op">=</span> <span class="dv">11</span> <span class="op">}</span> → <span class="op">{</span> state <span class="op">=</span> <span class="dv">11</span> <span class="op">}</span></span>
<span id="cb38-34"><a href="#cb38-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-35"><a href="#cb38-35" aria-hidden="true" tabindex="-1"></a>       <span class="co">/* { state = 01 ∨ state = 11 } ∧ { sink_item = full } */</span></span>
<span id="cb38-36"><a href="#cb38-36" aria-hidden="true" tabindex="-1"></a>       state machine invokes pull entry action <span class="op">(</span>none<span class="op">)</span></span>
<span id="cb38-37"><a href="#cb38-37" aria-hidden="true" tabindex="-1"></a>       <span class="co">/* post_entry: { state = 01 ∨ state = 11 } ∧ { sink_item = full } */</span> </span>
<span id="cb38-38"><a href="#cb38-38" aria-hidden="true" tabindex="-1"></a>     state machine unlocks mutex</span>
<span id="cb38-39"><a href="#cb38-39" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { mutex = unlocked */</span></span>
<span id="cb38-40"><a href="#cb38-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-41"><a href="#cb38-41" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* post_pull: { state = 01 ∨ state = 11 } ∧ { sink_item = full } */</span></span>
<span id="cb38-42"><a href="#cb38-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-43"><a href="#cb38-43" aria-hidden="true" tabindex="-1"></a>     client of the sink extracts the item  <span class="co">/* Note that although the Source can execute and potentially change the</span></span>
<span id="cb38-44"><a href="#cb38-44" aria-hidden="true" tabindex="-1"></a><span class="co">                                                state here, the allowable transitions do not end up changing it */</span></span>
<span id="cb38-45"><a href="#cb38-45" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∨ state = 11 } ∧ { sink_item = empty } */</span></span>
<span id="cb38-46"><a href="#cb38-46" aria-hidden="true" tabindex="-1"></a>     client invokes drain event to transition from full to empty </span>
<span id="cb38-47"><a href="#cb38-47" aria-hidden="true" tabindex="-1"></a>     state machine locks mutex</span>
<span id="cb38-48"><a href="#cb38-48" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∨ state = 11 } ∧ { sink_item = empty } */</span></span>
<span id="cb38-49"><a href="#cb38-49" aria-hidden="true" tabindex="-1"></a>     state machine performs exit action</span>
<span id="cb38-50"><a href="#cb38-50" aria-hidden="true" tabindex="-1"></a>     <span class="cf">if</span> <span class="op">{</span> state <span class="op">=</span> <span class="bn">01</span> ∨ state <span class="op">=</span> <span class="dv">11</span> <span class="op">}</span> → none</span>
<span id="cb38-51"><a href="#cb38-51" aria-hidden="true" tabindex="-1"></a>     <span class="op">{</span> state <span class="op">=</span> <span class="bn">01</span> ∨ state <span class="op">=</span> <span class="dv">11</span> <span class="op">}</span></span>
<span id="cb38-52"><a href="#cb38-52" aria-hidden="true" tabindex="-1"></a>     state machine performs transition</span>
<span id="cb38-53"><a href="#cb38-53" aria-hidden="true" tabindex="-1"></a>     <span class="op">{</span> state <span class="op">=</span> <span class="bn">01</span> <span class="op">}</span> → <span class="op">{</span> state <span class="op">=</span> <span class="bn">00</span> <span class="op">}</span></span>
<span id="cb38-54"><a href="#cb38-54" aria-hidden="true" tabindex="-1"></a>     <span class="op">{</span> state <span class="op">=</span> <span class="dv">11</span> <span class="op">}</span> → <span class="op">{</span> state <span class="op">=</span> <span class="dv">10</span> <span class="op">}</span></span>
<span id="cb38-55"><a href="#cb38-55" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∨ state = 10 } ∧ { sink_item = empty } */</span></span>
<span id="cb38-56"><a href="#cb38-56" aria-hidden="true" tabindex="-1"></a>     state machine performs entry action</span>
<span id="cb38-57"><a href="#cb38-57" aria-hidden="true" tabindex="-1"></a>       <span class="op">{</span> state <span class="op">=</span> <span class="bn">00</span> <span class="op">}</span> → notify_source</span>
<span id="cb38-58"><a href="#cb38-58" aria-hidden="true" tabindex="-1"></a>       <span class="op">{</span> state <span class="op">=</span> <span class="dv">10</span> <span class="op">}</span> → notify_source</span>
<span id="cb38-59"><a href="#cb38-59" aria-hidden="true" tabindex="-1"></a>     Sink returns</span>
<span id="cb38-60"><a href="#cb38-60" aria-hidden="true" tabindex="-1"></a>     state machine unlocks mutex</span>
<span id="cb38-61"><a href="#cb38-61" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* end_loop: { state = 00 ∨ state = 10 } ∧ { sink_item = empty } */</span></span>
<span id="cb38-62"><a href="#cb38-62" aria-hidden="true" tabindex="-1"></a>     At this point<span class="op">,</span> the source could inject<span class="op">,</span> fill<span class="op">,</span> push</span>
<span id="cb38-63"><a href="#cb38-63" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span> state <span class="op">=</span> <span class="bn">00</span> ∨ state <span class="op">=</span> <span class="bn">01</span> ∨ state <span class="op">=</span> <span class="dv">10</span> ∨ state <span class="op">=</span> <span class="dv">11</span> <span class="op">}</span> ∧ <span class="op">{</span> sink_item <span class="op">=</span> empty ∨ sink_item <span class="op">=</span> full<span class="op">}</span> <span class="op">*/</span></span>
<span id="cb38-64"><a href="#cb38-64" aria-hidden="true" tabindex="-1"></a>  <span class="co">/* post_loop: { state = 00 ∨ state = 10 } ∧ { sink_item = empty } */</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="summary-of-source-and-sink-proof-outline" class="level3">
<h3 class="anchored" data-anchor-id="summary-of-source-and-sink-proof-outline">Summary of Source and Sink Proof Outline</h3>
<p>From the above analysis, we can summarize the <code>Source</code> proof outline below. In a manner similar to how states are represented, we indicate whether items are empty or full using 0 or 1.</p>
<section id="source" class="level4">
<h4 class="anchored" data-anchor-id="source">Source</h4>
<div class="sourceCode" id="cb39"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>   <span class="cf">while</span> <span class="op">(</span>not done<span class="op">)</span> <span class="op">{</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∨ state = 01 } ∧ ( items = 00 ∨ items = 01 ) }   */</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>     inject</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∨ state = 01 } ∧ ( items = 10 ∨ items = 11 ) }   */</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>     fill</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∨ state = 01 ∨ state = 10 ∨ state = 11 } ∧       */</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { items = 00 ∨ items = 01 ∨ items = 10 ∨ state = 11 }         */</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>     push</span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∨ state = 01 } ∧ ( items = 00 ∨ items = 01 ) }   */</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="sink" class="level4">
<h4 class="anchored" data-anchor-id="sink">Sink</h4>
<p>From the above analysis, we can summarize the <code>Sink</code> proof outline as follows:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>   <span class="cf">while</span> <span class="op">(</span>not done<span class="op">)</span> <span class="op">{</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∨ state = 01 ∨ state = 10 ∨ state = 11 } ∧       */</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { items = 00 ∨ items = 01 ∨ items = 10 ∨ state = 11 }         */</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>     pull</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∨ state = 11 } ∧ { items = 01 ∨ items = 11 }     */</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>     extract</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∨ state = 11 } ∧ { items = 00 ∨ items = 10 }     */</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>     drain</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∨ state = 01 ∨ state = 10 ∨ state = 11 } ∧       */</span></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { items = 00 ∨ items = 01 ∨ items = 10 ∨ state = 11 }         */</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="source-proof" class="level3">
<h3 class="anchored" data-anchor-id="source-proof">Source Proof</h3>
<p>If we just consider the <code>Source</code> actions without considering concurrent <code>Sink</code> operations, we have the following proof outline:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>   <span class="cf">while</span> <span class="op">(</span>not done<span class="op">)</span> <span class="op">{</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∧ items = 00 } */</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>     inject<span class="op">:</span> items<span class="op">[</span><span class="dv">0</span><span class="op">]</span> ← <span class="dv">1</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∧ items = 10 } */</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>     fill<span class="op">:</span> state<span class="op">[</span><span class="dv">0</span><span class="op">]</span> ← <span class="dv">1</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 10 ∧ items = 10 } */</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>     push<span class="op">:</span> 〈 await ¬<span class="op">{</span> state <span class="op">=</span> <span class="dv">11</span> <span class="op">}</span> <span class="op">:</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>              <span class="cf">if</span> <span class="op">{</span> state <span class="op">=</span> <span class="dv">10</span> ∧ items <span class="op">=</span> <span class="dv">10</span> <span class="op">}</span> → <span class="op">{</span> state <span class="op">=</span> <span class="bn">01</span> ∧ items <span class="op">=</span> <span class="bn">01</span> <span class="op">}</span> ⟩</span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∧ { items = 01 } */</span></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We can make a second iteration of this proof outline, adding the condition <code>{ state = 01 ∧ items = 01 }</code> to the beginning, since that is the final state of the previous iteration:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>   <span class="cf">while</span> <span class="op">(</span>not done<span class="op">)</span> <span class="op">{</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∧ items = 00 } ∨ { state = 01 ∧ items = 01 } */</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>     inject<span class="op">:</span> items<span class="op">[</span><span class="dv">0</span><span class="op">]</span> ← <span class="dv">1</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∧ items = 10 } ∨ { state = 01 ∧ items = 11 } */</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>     fill<span class="op">:</span> state<span class="op">[</span><span class="dv">0</span><span class="op">]</span> ← <span class="dv">1</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 10 ∧ items = 10 } ∨ { state = 11 ∧ items = 11 } */</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>     push<span class="op">:</span> 〈 await ¬<span class="op">{</span> state <span class="op">=</span> <span class="dv">11</span> <span class="op">}</span> <span class="op">:</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>              <span class="cf">if</span> <span class="op">{</span> state <span class="op">=</span> <span class="dv">10</span> ∧ items <span class="op">=</span> <span class="dv">10</span> <span class="op">}</span> → <span class="op">{</span> state <span class="op">=</span> <span class="bn">01</span> ∧ items <span class="op">=</span> <span class="bn">01</span> <span class="op">}</span> ⟩</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∧ { items = 01 } */</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Note that if we enter push with <code>{ state = 11 }</code>, we will not exit until that state changes, which will require action from the <code>Sink</code>.</p>
</section>
<section id="sink-proof" class="level3">
<h3 class="anchored" data-anchor-id="sink-proof">Sink Proof</h3>
<p>If we just consider the <code>Sink</code> actions without considering concurrent <code>Source</code> operations, we have the following proof outline:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>   <span class="cf">while</span> <span class="op">(</span>not done<span class="op">)</span> <span class="op">{</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 10 ∧ items = 10 } */</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>     pull<span class="op">:</span> 〈 await ¬<span class="op">{</span> state <span class="op">=</span> <span class="bn">00</span> <span class="op">}</span> <span class="op">:</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>              <span class="cf">if</span> <span class="op">{</span> state <span class="op">=</span> <span class="dv">10</span> ∧ items <span class="op">=</span> <span class="dv">10</span> <span class="op">}</span> → <span class="op">{</span> state <span class="op">=</span> <span class="bn">01</span> ∧ items <span class="op">=</span> <span class="bn">01</span> <span class="op">}</span> ⟩</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∧ items = 01 } */</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>     extract<span class="op">:</span> extract<span class="op">:</span> item<span class="op">[</span><span class="dv">1</span><span class="op">]</span> ← <span class="dv">0</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∧ items = 00 } */</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>     drain<span class="op">:</span> state<span class="op">[</span><span class="dv">1</span><span class="op">]</span> ← <span class="dv">0</span>  </span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∧ items = 00 } */</span></span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>A second iteration of the <code>Sink</code> actions would result in</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>   <span class="cf">while</span> <span class="op">(</span>not done<span class="op">)</span> <span class="op">{</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∧ items = 00 } ∨ { state = 10 ∧ items = 10 } */</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>     pull<span class="op">:</span> 〈 await ¬<span class="op">{</span> state <span class="op">=</span> <span class="bn">00</span> <span class="op">}</span> <span class="op">:</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>              <span class="cf">if</span> <span class="op">{</span> state <span class="op">=</span> <span class="dv">10</span> ∧ items <span class="op">=</span> <span class="dv">10</span> <span class="op">}</span> → <span class="op">{</span> state <span class="op">=</span> <span class="bn">01</span> ∧ items <span class="op">=</span> <span class="bn">01</span> <span class="op">}</span> ⟩</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∧ { items = 01 } */</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>     extract<span class="op">:</span> extract<span class="op">:</span> item<span class="op">[</span><span class="dv">1</span><span class="op">]</span> ← <span class="dv">0</span></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∧ { items = 00 } */</span></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>     drain<span class="op">:</span> state<span class="op">[</span><span class="dv">1</span><span class="op">]</span> ← <span class="dv">0</span>  </span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∧ { items = 00 } */</span></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Here, we are stopped in the <code>await</code> statement, pending action by the <code>Source</code>.and still result in a valid proof outline.</p>
</section>
<section id="derivation-of-source-proof-with-concurrent-sink-actions" class="level3">
<h3 class="anchored" data-anchor-id="derivation-of-source-proof-with-concurrent-sink-actions">Derivation of Source Proof with Concurrent Sink Actions</h3>
<p>We now work through the <code>Source</code> proof, allowing arbitrary <code>Sink</code> actions to occur between any two <code>Source</code> action. The allowable <code>Sink</code> actions at any point must have the same predicate at the point where the <code>Sink</code> action occurs. For example, the predicate prior to <code>Source</code> <code>inject</code> includes <code>{ state = 01 ∧ items = 01 }</code>, which is also a predicate prior to extract. Thus, <code>extract</code> could also occur prior to <code>inject</code>. We can therefore include the predicate resulting from the <code>extract</code> action as part of the predicate prior to <code>inject</code>. Applying allowable <code>Sink</code> actions in this fashion to all of the <code>Source</code> predicates, we obtain:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>   <span class="cf">while</span> <span class="op">(</span>not done<span class="op">)</span> <span class="op">{</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∧ items = 00 } ∨ { state = 01 ∧ ( items = 00 ∨ items = 01 ) } */</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* extract: { state = 01 ∧ items = 01 } → { state = 01 ∧ items = 00 } */</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* drain: { state = 01 ∧ items = 00 } → { state = 00 ∧ items = 00 } */</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* pull: no change</span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a><span class="co">     /* { state = 00 ∧ items = 00 } ∨ { state = 01 ∧ ( items = 00 ∨ items = 01 ) } */</span></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>     inject<span class="op">:</span> items<span class="op">[</span><span class="dv">0</span><span class="op">]</span> ← <span class="dv">1</span></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∧ items = 10 } ∨ { state = 01 ∧ ( items = 10 ∨ items = 11 ) } */</span></span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* extract: { state = 01 ∧ items = 11 } → { state = 01 ∧ items = 10 } */</span></span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* drain: { state = 01 ∧ items = 10 } → { state = 00 ∧ items = 10 } */</span></span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* pull: no change</span></span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true" tabindex="-1"></a><span class="co">     /* { state = 00 ∧ items = 10 } ∨ { state = 01 ∧ ( items = 10 ∨ items = 11 ) } */</span></span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true" tabindex="-1"></a>     fill<span class="op">:</span> state<span class="op">[</span><span class="dv">0</span><span class="op">]</span> ← <span class="dv">1</span></span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 10 ∧ items = 10 } ∨ { state = 11 ∧ ( items = 10 ∨ items = 11 ) } */</span></span>
<span id="cb45-19"><a href="#cb45-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-20"><a href="#cb45-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* extract: { state = 11 ∧ items = 11 } → { state = 11 ∧ items = 10 } */</span></span>
<span id="cb45-21"><a href="#cb45-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* drain: { state = 11 ∧ items = 10 } → { state = 10 ∧ items = 10 } */</span></span>
<span id="cb45-22"><a href="#cb45-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* pull: { state = 10 ∧ items = 10 } → { state = 01 ∧ items = 01 } */</span></span>
<span id="cb45-23"><a href="#cb45-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* pull+extract: { state = 01 ∧ items = 01 } → { state = 01 ∧ items = 00 } */</span></span>
<span id="cb45-24"><a href="#cb45-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* pull+extract+drain: { state = 01 ∧ items = 00 } → { state = 00 ∧ items = 00 } */</span></span>
<span id="cb45-25"><a href="#cb45-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-26"><a href="#cb45-26" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∧ items = 00 } ∨ { state = 01 ∧ ( items = 00 ∨ items = 01 ) } ∨ */</span></span>
<span id="cb45-27"><a href="#cb45-27" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 10 ∧ items = 10 } ∨ { state = 11 ∧ ( items = 10 ∨ items = 11 ) } */</span></span>
<span id="cb45-28"><a href="#cb45-28" aria-hidden="true" tabindex="-1"></a>     push<span class="op">:</span> 〈 await ¬<span class="op">{</span> state <span class="op">=</span> <span class="dv">11</span> <span class="op">}</span> <span class="op">:</span></span>
<span id="cb45-29"><a href="#cb45-29" aria-hidden="true" tabindex="-1"></a>              <span class="cf">if</span> <span class="op">{</span> state <span class="op">=</span> <span class="dv">10</span> ∧ items <span class="op">=</span> <span class="dv">10</span> <span class="op">}</span> → <span class="op">{</span> state <span class="op">=</span> <span class="bn">01</span> ∧ items <span class="op">=</span> <span class="bn">01</span> <span class="op">}</span> ⟩</span>
<span id="cb45-30"><a href="#cb45-30" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∧ items = 00 } ∨ { state = 01 ∧ ( items = 00 ∨ items = 01 ) } */</span></span>
<span id="cb45-31"><a href="#cb45-31" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="derivation-of-sink-proof-with-concurrent-source-actions" class="level3">
<h3 class="anchored" data-anchor-id="derivation-of-sink-proof-with-concurrent-source-actions">Derivation of Sink Proof with Concurrent Source Actions</h3>
<p>Applying the same process to the <code>Sink</code> proof outline as we did for the <code>Source</code> proof outline:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>   <span class="cf">while</span> <span class="op">(</span>not done<span class="op">)</span> <span class="op">{</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∧ items = 00 } ∨ { state = 10 ∧ items = 10 } */</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>       <span class="co">/* inject: { state = 00 ∧ items = 00 } → { state = 00 ∧ items = 10 }</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a><span class="co">       /* inject+fill: { state = 00 ∧ items = 10 } → { state = 10 ∧ items = 10 }</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a><span class="co">       /* inject+fill+push: { state = 10 ∧ items = 10 } → { state = 01 ∧ items = 01 }</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a><span class="co">       /* inject+fill+push+inject: { state = 01 ∧ items = 01 } → { state = 01 ∧ items = 11 }</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a><span class="co">       /* inject+fill+push+inject+fill: { state = 01 ∧ items = 11 } → { state = 11 ∧ items = 11 }</span></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a><span class="co">     /* { state = 00 ∧ ( items = 00 ∨ items = 10 ) } ∨ { state = 10 ∧ items = 10 } ∨  */</span></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∧ ( items = 01 ∨ items = 11 ) } ∨ { state = 11 ∧ items = 11 ) }  */</span></span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>     pull<span class="op">:</span> 〈 await ¬<span class="op">{</span> state <span class="op">=</span> <span class="bn">00</span> <span class="op">}</span> <span class="op">:</span></span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a>              <span class="cf">if</span> <span class="op">{</span> state <span class="op">=</span> <span class="dv">10</span> ∧ items <span class="op">=</span> <span class="dv">10</span> <span class="op">}</span> → <span class="op">{</span> state <span class="op">=</span> <span class="bn">01</span> ∧ items <span class="op">=</span> <span class="bn">01</span> <span class="op">}</span> ⟩</span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∧ ( items = 01 ∨ items = 11 ) } ∨ { state = 11 ∧ items = 11 ) } */</span></span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a>       <span class="co">/* inject: { state = 01 ∧ items = 01 } → { state = 01 ∧ items = 11 } */</span></span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a>       <span class="co">/* fill: { state = 01 ∧ items = 01 } → { state = 11 ∧ items = 11 } */</span></span>
<span id="cb46-18"><a href="#cb46-18" aria-hidden="true" tabindex="-1"></a>       <span class="co">/* push: no change </span></span>
<span id="cb46-19"><a href="#cb46-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-20"><a href="#cb46-20" aria-hidden="true" tabindex="-1"></a><span class="co">     /* { state = 01 ∧ ( items = 01 ∨ items = 11 ) } ∨ { state = 11 ∧ items = 11 ) } */</span></span>
<span id="cb46-21"><a href="#cb46-21" aria-hidden="true" tabindex="-1"></a>     extract<span class="op">:</span> extract<span class="op">:</span> item<span class="op">[</span><span class="dv">1</span><span class="op">]</span> ← <span class="dv">0</span></span>
<span id="cb46-22"><a href="#cb46-22" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∧ ( items = 00 ∨ items = 10 ) } ∨ { state = 11 ∧ items = 01 ) } */</span></span>
<span id="cb46-23"><a href="#cb46-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-24"><a href="#cb46-24" aria-hidden="true" tabindex="-1"></a>       <span class="co">/* inject: { state = 01 ∧ items = 00 } → { state = 01 ∧ items = 10 } */</span></span>
<span id="cb46-25"><a href="#cb46-25" aria-hidden="true" tabindex="-1"></a>       <span class="co">/* fill: { state = 01 ∧ items = 11 } → { state = 11 ∧ items = 10 } */</span></span>
<span id="cb46-26"><a href="#cb46-26" aria-hidden="true" tabindex="-1"></a>       <span class="co">/* push: no change </span></span>
<span id="cb46-27"><a href="#cb46-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-28"><a href="#cb46-28" aria-hidden="true" tabindex="-1"></a><span class="co">     /* { state = 01 ∧ ( items = 00 ∨ items = 10 ) } ∨ { state = 11 ∧ items = 01 ) } */</span></span>
<span id="cb46-29"><a href="#cb46-29" aria-hidden="true" tabindex="-1"></a>     drain<span class="op">:</span> state<span class="op">[</span><span class="dv">1</span><span class="op">]</span> ← <span class="dv">0</span>  </span>
<span id="cb46-30"><a href="#cb46-30" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∧ ( items = 00 ∨ items = 10 ) } ∨ { state = 10 ∧ items = 01 ) } */</span></span>
<span id="cb46-31"><a href="#cb46-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-32"><a href="#cb46-32" aria-hidden="true" tabindex="-1"></a>       <span class="co">/* inject: { state = 00 ∧ items = 00 } → { state = 00 ∧ items = 10 }</span></span>
<span id="cb46-33"><a href="#cb46-33" aria-hidden="true" tabindex="-1"></a><span class="co">       /* inject+fill: { state = 00 ∧ items = 10 } → { state = 10 ∧ items = 10 }</span></span>
<span id="cb46-34"><a href="#cb46-34" aria-hidden="true" tabindex="-1"></a><span class="co">       /* inject+fill+push: { state = 10 ∧ items = 10 } → { state = 01 ∧ items = 01 }</span></span>
<span id="cb46-35"><a href="#cb46-35" aria-hidden="true" tabindex="-1"></a><span class="co">       /* inject+fill+push+inject: { state = 01 ∧ items = 01 } → { state = 01 ∧ items = 11 }</span></span>
<span id="cb46-36"><a href="#cb46-36" aria-hidden="true" tabindex="-1"></a><span class="co">       /* inject+fill+push+inject+fill: { state = 01 ∧ items = 11 } → { state = 11 ∧ items = 11 }</span></span>
<span id="cb46-37"><a href="#cb46-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-38"><a href="#cb46-38" aria-hidden="true" tabindex="-1"></a><span class="co">     /* { state = 00 ∧ ( items = 00 ∨ items = 10 ) } ∨ { state = 10 ∧ items = 10 } ∨  */</span></span>
<span id="cb46-39"><a href="#cb46-39" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∧ ( items = 01 ∨ items = 11 ) } ∨ { state = 11 ∧ items = 11 ) }  */</span></span>
<span id="cb46-40"><a href="#cb46-40" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="summary-of-final-source-and-sink-proof-outline" class="level3">
<h3 class="anchored" data-anchor-id="summary-of-final-source-and-sink-proof-outline">Summary of Final Source and Sink Proof Outline</h3>
<p>Summarizing the proof outlines above (including only the relevant predicates), we obtain the proof outlines below. Note that these are compatible with the previously derived proof outlines, but the predicates exclude certain combinations of <code>states</code> and <code>items</code>. Where helpful, we include these predicates as comments in the dag source code files.</p>
<section id="source-1" class="level4">
<h4 class="anchored" data-anchor-id="source-1">Source</h4>
<div class="sourceCode" id="cb47"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>   <span class="cf">while</span> <span class="op">(</span>not done<span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∧ items = 00 } ∨ { state = 01 ∧ ( items = 00 ∨ items = 01 ) }   */</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>     inject<span class="op">:</span> items<span class="op">[</span><span class="dv">0</span><span class="op">]</span> ← <span class="dv">1</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∧ items = 10 } ∨ { state = 01 ∧ ( items = 10 ∨ items = 11 ) }   */</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>     fill<span class="op">:</span> state<span class="op">[</span><span class="dv">0</span><span class="op">]</span> ← <span class="dv">1</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∧ items = 00 } ∨ { state = 01 ∧ ( items = 00 ∨ items = 01 ) } ∨ */</span></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 10 ∧ items = 10 } ∨ { state = 11 ∧ ( items = 10 ∨ items = 11 ) }   */</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>     push<span class="op">:</span> 〈 await ¬<span class="op">{</span> state <span class="op">=</span> <span class="dv">11</span> <span class="op">}</span> <span class="op">:</span></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>              <span class="cf">if</span> <span class="op">{</span> state <span class="op">=</span> <span class="dv">10</span> ∧ items <span class="op">=</span> <span class="dv">10</span> <span class="op">}</span> → <span class="op">{</span> state <span class="op">=</span> <span class="bn">01</span> ∧ items <span class="op">=</span> <span class="bn">01</span> <span class="op">}</span> ⟩</span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∧ items = 00 } ∨ { state = 01 ∧ ( items = 00 ∨ items = 01 ) }   */</span>     </span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="sink-1" class="level4">
<h4 class="anchored" data-anchor-id="sink-1">Sink</h4>
<div class="sourceCode" id="cb48"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>   <span class="cf">while</span> <span class="op">(</span>not done<span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∧ ( items = 00 ∨ items = 10 ) } ∨ { state = 10 ∧ items = 10 } ∨ */</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∧ ( items = 01 ∨ items = 11 ) } ∨ { state = 11 ∧ items = 11 ) } */</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>     pull<span class="op">:</span> 〈 await ¬<span class="op">{</span> state <span class="op">=</span> <span class="bn">00</span> <span class="op">}</span> <span class="op">:</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>              <span class="cf">if</span> <span class="op">{</span> state <span class="op">=</span> <span class="dv">10</span> ∧ items <span class="op">=</span> <span class="dv">10</span> <span class="op">}</span> → <span class="op">{</span> state <span class="op">=</span> <span class="bn">01</span> ∧ items <span class="op">=</span> <span class="bn">01</span> <span class="op">}</span> ⟩</span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∧ ( items = 01 ∨ items = 11 ) } ∨ { state = 11 ∧ items = 11 ) } */</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>     extract<span class="op">:</span> extract<span class="op">:</span> item<span class="op">[</span><span class="dv">1</span><span class="op">]</span> ← <span class="dv">0</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∧ ( items = 00 ∨ items = 10 ) } ∨ { state = 11 ∧ items = 01 ) } */</span></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>     drain<span class="op">:</span> state<span class="op">[</span><span class="dv">1</span><span class="op">]</span> ← <span class="dv">0</span>  </span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∧ ( items = 00 ∨ items = 10 ) } ∨ { state = 10 ∧ items = 10 } ∨ */</span></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∧ ( items = 01 ∨ items = 11 ) } ∨ { state = 11 ∧ items = 11 ) } */</span></span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>


</section>
</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/TileDB-Inc\.github\.io\/TileDB\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>